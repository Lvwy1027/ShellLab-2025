# ShellLab：构建 Unix Shell 🐚

## 实验指导文档

### Unix Shell 的工作原理 🔍

Unix Shell 是操作系统与用户交互的接口，它接收用户输入的命令，解析后执行相应的程序。Shell 的核心工作流程可以概括为：读取命令、解析命令、执行命令、等待执行完成、循环重复以上步骤。在这个过程中涉及进程控制、信号处理、I/O重定向等多个系统概念。

当用户输入命令后，Shell 会首先检查是否为内建命令。内建命令由 Shell 进程自身执行，不需要创建子进程。对于非内建命令，Shell 会创建子进程并在其中执行相应程序。这种设计使得 Shell 能够提供统一的命令执行环境，同时保持自身的稳定运行。

### 进程控制与作业管理 🧵

进程是程序的执行实例，Shell 通过 `fork()` 系统调用创建子进程，然后通过 `execve()` 系统调用在子进程中加载并执行新程序。这种"fork-exec"模式是 Unix 系统进程创建的基础机制。

作业控制允许用户管理多个并行任务。在 Shell 中，一个作业可以在前台或后台运行。前台作业会占用终端，Shell 会等待其完成；后台作业则在后台执行，Shell 可以同时接受新的命令。用户可以通过 `bg` 和 `fg` 命令在前台和后台间切换作业，通过 `jobs` 命令查看所有后台作业。

实现作业控制需要跟踪所有子进程的状态。在本实验中，我们使用全局作业表记录作业信息，包括进程ID、作业ID、状态和命令行。每个作业都有唯一的作业ID，可以通过 `%JID` 或 PID 引用。

### 信号处理机制 📡

信号是一种软件中断，用于通知进程发生了某种事件。Shell 需要处理三类关键信号：

SIGCHLD 信号在子进程状态改变时发送给父进程。Shell 需要捕获这个信号并回收终止的子进程，防止它们变成僵尸进程。此外，还需要更新作业表以反映子进程的最新状态。

SIGINT 信号在用户按下 Ctrl+C 时产生，通常用于中断前台程序。Shell 应该捕获此信号并将其转发给前台进程组，而不是自己终止。

SIGTSTP 信号在用户按下 Ctrl+Z 时产生，用于暂停前台程序。Shell 同样需要捕获并转发此信号给前台进程组。

信号处理需要特别注意竞态条件。例如，在 `fork()` 子进程后，父进程可能在将新作业添加到作业表之前就收到 SIGCHLD 信号，导致子进程状态无法正确跟踪。解决方案是在 `fork()` 前使用 `sigprocmask()` 暂时阻塞 SIGCHLD 信号，在完成作业表更新后再解除阻塞。

### I/O 重定向与管道 🔄

I/O 重定向允许程序从文件而非标准输入读取数据，或将输出写入文件而非标准输出。Shell 使用 `<` 符号表示输入重定向，`>` 和 `>>` 符号表示输出重定向（后者为追加模式）。

实现重定向的关键是使用 `open()` 系统调用打开相应文件，然后通过 `dup2()` 系统调用将标准输入/输出文件描述符重定向到打开的文件。对于子进程，这些重定向操作应在 `execve()` 之前完成。

管道是一种进程间通信机制，允许一个进程的输出直接作为另一个进程的输入。Shell 使用 `|` 符号表示管道连接。实现管道需要使用 `pipe()` 系统调用创建管道，然后分别 `fork()` 出管道两端的进程，并通过 `dup2()` 连接管道与标准输入/输出。

对于复杂的管道链，可以采用递归方式处理，每次处理链中的一个命令，并正确设置其输入输出重定向。

### 终端控制机制 🖥️

终端控制是 Shell 高级功能之一，它涉及进程组、会话和控制终端的概念。每个终端同一时刻只能被一个进程组控制，这个进程组称为前台进程组。其他进程组为后台进程组，它们无法直接从终端读取输入。

正确实现终端控制需要使用 `tcsetpgrp()` 函数设置终端的前台进程组。当作业在前台和后台之间切换时，Shell 需要相应地更新控制终端的所有权。此外，还需要正确处理终端属性和模式切换，以支持 vim、gdb 等交互式程序的运行。

实现终端控制的关键步骤：
1. 在 `fork()` 后，子进程应调用 `setpgid(0, 0)` 创建新的进程组
2. 对于前台作业，Shell 应调用 `tcsetpgrp()` 将终端控制权交给该作业的进程组
3. 作业完成或被挂起后，Shell 应重新获取终端控制权
4. 将后台作业切换到前台时，应使用 `tcsetpgrp()` 更新终端控制权

### 环境变量与命令替换 🧩

环境变量是操作系统维护的一组动态值，可以被程序访问。Shell 支持环境变量展开功能，允许用户在命令中使用 `$VAR` 或 `${VAR}` 语法引用环境变量的值。

实现环境变量展开需要识别命令行中的变量引用，使用 `getenv()` 函数获取对应的环境变量值，然后替换原字符串中的变量引用。这通常需要使用正则表达式或字符串匹配算法。

命令替换是 Shell 的高级功能，允许用户使用 `$(command)` 语法将命令的输出作为另一个命令的参数。实现命令替换需要创建子进程执行被替换的命令，捕获其输出，然后将输出替换到原命令行中。这通常需要使用管道和临时文件。

### 实现策略与常见问题 🛠️

实现 Shell 是一个复杂任务，建议采用渐进式方法：先实现基本命令执行，再添加信号处理，然后是作业控制，最后是I/O重定向和管道。每完成一个阶段就进行测试，确保功能正确再进行下一步。

常见问题及解决方案：

竞态条件：使用 `sigprocmask()` 在关键区域暂时阻塞信号，避免信号处理函数与主程序逻辑的竞争。

僵尸进程：在 SIGCHLD 处理函数中使用 `waitpid()` 及时回收终止的子进程，更新作业表状态。

信号转发：使用负的PID值（如 `kill(-pid, sig)`）向整个进程组发送信号，确保前台作业的所有进程都能收到信号。

前台等待：实现 `waitfg()` 函数等待前台作业完成，可以使用轮询方式，定期检查作业状态。

资源泄漏：确保关闭所有打开的文件描述符，释放分配的内存，避免资源泄漏。

错误处理：检查每个系统调用的返回值，及时处理错误情况，提高程序鲁棒性。

### 深入理解Shell与操作系统的交互 🔄

Shell 是理解操作系统核心概念的绝佳窗口。通过实现 Shell，你将深入了解进程创建与终止、信号处理、I/O操作、进程间通信等机制。这些概念不仅是操作系统的基础，也是系统编程的核心知识。

在实现过程中，建议查阅相关系统调用的手册页（man pages），理解它们的参数和返回值，尤其是错误情况的处理。同时，学会使用调试工具如 gdb 和 strace，它们可以帮助你跟踪程序执行和系统调用。

希望通过本实验，你能对操作系统的进程管理、信号处理和I/O机制有更深入的理解，并培养系统级编程的能力。祝你实验顺利！
